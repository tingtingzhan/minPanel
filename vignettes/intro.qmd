---
title: "minPanel"
author: Tingting Zhan
date: "`r Sys.Date()`"
format: 
  html:
    page-layout: full
    html-math-method: katex
number-sections: true
toc: true
toc-location: left
toc-depth: 4
toc-title: ''
editor: source
knitr:
  opts_chunk: 
    collapse: true
    comment: "#" 
bibliography: minPanel.bib
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This vignette of package **`minPanel`** ([Github](https://github.com/tingtingzhan/minPanel)) presents ...

To cite this methodology, please use @Zezulinski25.


Package **`minPanel`** `Imports` packages

-   **`cli`** [@cli, v`r packageVersion('cli')`], for attractive command line interfaces
-   **`consort`** [@consort, v`r packageVersion('consort')`], for Consolidated Standards of Reporting Trials (CONSORT) diagram
-   **`flextable`** [@flextable, v`r packageVersion('flextable')`], for flexible table
-   **`ggplot2`** [@ggplot2], **`patchwork`** [@patchwork], for visualization
-   `r '\U1f5dd'` **`matrixStats`** [@matrixStats, v`r packageVersion('matrixStats')`], key dependency, for matrix algebra
-   `r '\U1f5dd'` **`methods`** shipped with vanilla `r R.version.string`, key dependencies, for `S4` generic function and method dispatches
-   **`scales`** [@scales, v`r packageVersion('scales')`], for colour pallete


## Prerequisite

Packages **`minPanel`** requires R version 4.5.0 (released 2025-04-11) or higher ([macOS](https://cran.r-project.org/bin/macosx/), [Windows](https://cran.r-project.org/bin/windows/base/)). An Integrated Development Environment (IDE), e.g., [RStudio](https://posit.co/download/rstudio-desktop/) or [Positron](https://positron.posit.co/download.html), is not required, but highly recommended. This vignette is created under `r R.version$version.string` using packages **`knitr`** [@knitr, v`r packageVersion('knitr')`], **`quarto`** [@quarto, v`r packageVersion('quarto')` with [Quarto](https://quarto.org/docs/get-started/) v`r quarto::quarto_version()`] and **`rmarkdown`** [@rmarkdown, v`r packageVersion('rmarkdown')`].

```{r}
#| code-fold: true
#| code-summary: "Environment on author's computer"
Sys.info()[c('sysname', 'release', 'machine')]
R.version
```

Experimental (and maybe unstable) features are released *extremely frequently* to [Github](https://github.com/tingtingzhan/minPanel). <!--Stable releases to [CRAN](https://CRAN.R-project.org/package=minPanel) are typically updated every 2 to 3 months.-->

```{r}
#| eval: false
remotes::install_github('tingtingzhan/minPanel')
```


```{r}
#| eval: false
#| echo: false
utils::install.packages('minPanel')
```

## Getting Started

Examples in this vignette require that the `search` path has

```{r}
library(minPanel)
library(ggplot2)
library(flextable)
```



# Data Set

Data from @Zezulinski25 is included in package **`minPanel`**.

Data object *`m1`* in package **`minPanel`** is a `logical` `matrix` of `r nrow(m1)` variants in `r ncol(m1)` early & late stage, i.e., *positive*, patients.

```{r}
m1 |> 
  dim()
```

```{r}
m1 |> 
  head(n = c(3L, 3L))
```

Data object *`m0`* in package **`minPanel`** is a `logical` `matrix` of the same `r nrow(m0)` variants in `r ncol(m0)` UPC, i.e., *negative*, patients.

```{r}
m0 |> 
  dim()
```

```{r}
m0 |> 
  head(n = c(3L, 3L))
```

# `panel`

Function `panel()` identifies the variants that identifies the same set of subjects in both *`m1`* and *`m0`*.  These variants are considered identical in terms of *`m1`* and *`m0`*.  Therefore they are put in one **variant-collection**.  We use *"collection"* for short in this vignette.

```{r}
m = panel(m1 = m1, m0 = m0)
```

Function `panel()` returns an object of `S4` class `'panel'`, with `slot`s

-   `@m1`, a `logical` `matrix`, collections on rows and positive subjects on columns
-   `@m0`, a `logical` `matrix`, collections on rows and negative subjects on columns
-   `@id`, a `list` of `character` `vector`s.  Each `character` `vector` contains the variants in a collection. 
-   `@label`, an optional `character` scalar

The `S4` method dispatch of `show` to `signature = 'panel'` prints the vital information, e.g., the number of collections, and the number of positive and negative subjects.

```{r}
m
```

In other words, the `r nrow(m1)` variants in both *`m1`* and *`m0`* are consolidated into `r length(m@id)` collections.  For example, the variants below identify the same set of positive and negative subjects, thus they are consolidated as one collection.

```{r}
#| code-fold: true
#| code-summary: e.g., variants consolidated in one collection
m@id[[8L]] |>
  cat(sep = '\n')
```


# Selected `panel`

```{r}
x0 = m |>
  subset(subset = true_positive > 0L) |>
  subset(subset = false_positive <= 0L, append.label = TRUE) |>
  sort_by(y = ~ true_positive, decreasing = TRUE) |>
  subset(subset = diff(cum_true_positive) > 0L) |>
  append_label(info = 'cum_false_positive')
```


The pipeline above consists of five steps.

1. The `S3` method dispatch `subset.panel()` (Appendix @sec-subset) selects the collections that identify at least one positive subjects *per collection* (Appendix @sec-positive).
2. The `S3` method dispatch `subset.panel()` selects the collections that identify none of the negative subjects *per collection* (Appendix @sec-positive).  The [*per collection* criterion]{style="background-color: #FFFF00"} *`'False(+) â‰¤0/31'`* is `append`ed to the `@label` of the output.
3. The `S3` method dispatch `sort_by.panel()` (Appendix @sec-sortby) sorts the collections by their number of true positives.
4. The `S3` method dispatch `subset.panel()` identifies the collections, so that each one collection identifies at least one more positive subjects than all the preceding collections (Appendix @sec-cum-positive).
5. Function `append_label()` (Appendix @sec-appendlabel) summarizes the number of negative subjects identified *as a panel of collections* (Appendix @sec-cum-positive).  The [*panel-wise* criterion]{style="background-color: #FFFF00"} *`'panelFalse(+) â‰¤0/31'`* is `append`ed to the `@label` of the output.


```{r}
x0
```

Function `consort.panel()` (Appendix @sec-consort) presents a Consolidated Standards of Reporting Trials (CONSORT) diagram of the creation of a selected panel.  @fig-consort0 shows the creation of *`x0`*.

```{r}
#| fig-height: 2.5
#| fig-width: 5
#| fig-align: left
#| fig-cap: 'CONSORT Diagram of *`x0`*'
#| label: fig-consort0
x0 |>
  consort.panel()
```


Next, we create

```{r}
#| code-fold: true
#| code-summary: 'A `panel` *`x1`*: controlled at `false_positive <= 1L` per collection'
x1 = m |>
  subset(subset = true_positive > 0L) |>
  subset(subset = false_positive <= 1L, append.label = TRUE) |>
  sort_by(y = ~ true_positive, decreasing = TRUE) |>
  subset(subset = diff(cum_true_positive) > 0L) |>
  append_label(info = 'cum_false_positive')
```

Panel *`x1`* has a *panel-wise* false positive of 7 out of 31 negative subjects.
 
```{r}
x1
```

Similarly, we create

```{r}
#| code-fold: true
#| code-summary: 'A `panel` *`x2`*: controlled at `false_positive <= 2L` per collection'
x2 = m |>
  subset(subset = true_positive > 0L) |>
  subset(subset = false_positive <= 2L, append.label = TRUE) |>
  sort_by(y = ~ true_positive, decreasing = TRUE) |>
  subset(subset = diff(cum_true_positive) > 0L) |>
  append_label(info = 'cum_false_positive')
x2
```



```{r}
#| code-fold: true
#| code-summary: 'A `panel` *`x3`*: controlled at `false_positive <= 3L` per collection'
x3 = m |>
  subset(subset = true_positive > 0L) |>
  subset(subset = false_positive <= 3L, append.label = TRUE) |>
  sort_by(y = ~ true_positive, decreasing = TRUE) |>
  subset(subset = diff(cum_true_positive) > 0L) |>
  append_label(info = 'cum_false_positive')
x3
```




# Operating Characteristics

Function `panellist()` collects multiple `panel`s.

```{r}
z = panellist(x0, x1, x2, x3)
```

The `S3` method dispatch `base::print.listof()` displays a `panellist`.

```{r}
#| code-fold: true
#| code-summary: 'A `panellist` *`z`*'
z
```


## Visualization

The `S3` method dispatches `autoplot.panellist()` and `autolayer.panellist()` visualize the operating characteristics of panels *`x0`*, *`x1`*, *`x2`* and *`x3`* in @fig-panellist.  

@fig-panellist concludes that the panel *`x1`*, controlled at per-collection false positive of `<=1/31` (colored [**green**]{style="color: #7CAE00"}), is the optimal among the four panels, as

-   Panel *`x0`*, controlled at a more stringent criterion of per-collection false positive of `<=0/31`, detects substantially less true-positives.  In other words, compared to panel *`x1`*, panel *`x0`* loses substantial power to detect true-positive due to a more stringent control of false-positive.
-   Panels *`x2`* and *`x3`*, controlled at less stringent criteria of per-collection false positive of `<=2/31` and `<=3/31`, respectively, have almost identical operating characteristics as panel *`x1`*.  In other words, compared to panel *`x1`*, panels *`x2`* and *`x3`* have no improvement on detection of true-positive, at the cost of higher false-positive.

```{r}
#| fig-height: 3
#| fig-width: 6
#| fig-align: left
#| fig-cap: 'Operating Characteristics of `panellist` *`z`*'
#| label: fig-panellist
z |> 
  autoplot()
```

## Print Selected Collections


The `S3` method dispatch `as_flextable.panellist()` displays the collections selected in each `panel`.  The collections that contain more than one variants are highlighted using the [light-yellow]{style="background-color: lightyellow"} color.

```{r}
z |> 
  as_flextable()
```


# Appendix

## True & False Positives {#sec-positive}

Funtions `true_positive()` and `false_positive()` ðŸš§

## Cumulative True & False Positives {#sec-cum-positive}

Function `cum_true_positive()` and `cum_false_positive()` ðŸš§ 

## `subset.panel()` {#sec-subset}  

The `S3` method dispatch `subset.panel()` ðŸš§

## `sort_by.panel()` {#sec-sortby}

The `S3` method dispatch `sort_by.panel()` ðŸš§

## `append_label()` {#sec-appendlabel}

Function `append_label()` ðŸš§

## `consort.panel()` {#sec-consort}

Function `consort.panel()` ..


## `consort.panellist()` {#sec-consort-panellist}

Function `consort.panellist()` .. @fig-consort

```{r}
#| fig-height: 3.5
#| fig-width: 10
#| fig-align: left
#| fig-cap: 'CONSORT Diagram of `panellist`'
#| label: fig-consort
z[1:3] |> 
  consort.panellist(nrow = 1L)
```


# What We Don't Do

## For `subset.panel()`

## by Multiple Criteria

too difficult to parse..

```{r}
#| eval: false
m |> 
  subset.panel(subset = (true_positive > 0L) & (false_positive <= 3L))
```

## by Cumulative False Positives

left with too small panel

```{r}
m |>
  subset(subset = true_positive > 0L) |>
  subset(subset = false_positive <= 1L) |>
  sort_by(y = ~ true_positive, decreasing = TRUE) |>
  subset(subset = cum_false_positive <= 1L, append.label = TRUE) |>
  subset(subset = diff(cum_true_positive) > 0L)
```


# References

::: {#refs}
:::
